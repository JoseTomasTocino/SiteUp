En este capítulo se presentan los detalles de diseño del proyecto, basándonos en
el análisis mostrado en los anteriores apartados. Se detallan la arquitectura
general y el diseño físico de datos entre otros aspectos.

\section{Arquitectura del sistema}

\subsection{Arquitectura física}

En este apartado, describimos los principales componentes hardware que forman la
arquitectura física de nuestro sistema, recogiendo por un lado los componentes
del servidor de producción y, por otro lado, los componentes del cliente de acceso.

\subsubsection{Servidor de producción}
\label{subsec:entorno-produccion}

\paragraph{Hardware}

El hardware mínimo indispensable para la correcta ejecución del motor del
proyecto se detalla en la siguiente lista:

\begin{itemize}
\item 512MiB de memoria RAM como mínimo.
\item 10GiB de disco duro como mínimo.
\item Acceso a internet con un canal de subida de al menos 1Mbit/s.
\end{itemize}

\paragraph{Software}

En cuanto al software necesario para la ejecución del proyecto, se detallan los
siguientes elementos, que es necesario instalar antes de desplegar el sistema:

\begin{itemize}
\item Sistema operativo \textbf{GNU/Linux}, preferiblemente basado en paquetería Debian.
\item Código fuente del proyecto \textbf{SiteUp}.
\item Servidor de shell remota \textbf{SSH}, accesible desde el exterior.
\item \textbf{Nginx}, servidor web trabajando en modo de proxy inverso.
\item \textbf{Supervisord}, sistema para el control de procesos que trabajen en modo demonio..
\item \textbf{RabbitMQ}, cola de tareas sencilla que cumple el estandar \ac{AMQP}.
\item Intérprete de \textbf{Python}, versión mínima 2.7.
\item Soporte de entornos virtuales \textbf{VirtualEnv} para la encapsulación de
  dependencias.
\end{itemize}

Una vez satisfechos los anteriores requisitos, el proyecto SiteUp instalará una
serie de dependencias propias, de forma encapsulada dentro de un entorno
virtual. Algunas de las dependencias más importantes son:

\begin{itemize}
\item \textbf{Django}, framework web en el que se basa el proyecto.
\item \textbf{Celery}, cola de tareas asíncronas.
\item \textbf{Fabric}, servicio para la creación de scripts de despligue en servidores remotos.
\item \textbf{Gunicorn}, servidor para aplicaciones web desarrolladas en Python
  basadas en el estándar WSGI.
\item Bibliotecas auxiliares para el lanzamiento de diversos tipos de chequeos
  en red: \textbf{requests}, \textbf{dnspython} y \textbf{urllib}.
\end{itemize}

De igual modo para el desarrollo del lado \textit{front-end} de la web existen
ciertas dependencias, instalables en forma de módulos de Node JS. Las
dependencias más importantes son:

\begin{itemize}
\item \textbf{Sass}, lenguaje de hojas de estilo que amplía las funcionalidades
  de CSS. El código Sass compila a código CSS válido.
\item \textbf{Compass}, framework para Sass que añade numerosas funciones y
  \textit{mixins} para facilitar el desarrollo front-end.
\item \textbf{Grunt}, un lanzador que automatiza la ejecución de tareas comunes
  y tediosas escrito en JavaScript.
\end{itemize}

\subsubsection{Cliente de acceso web}

El requisito no funcional NRQ-4, presente en el cuadro~\ref{tab:accesibilidad}
indica que la plataforma web deberá ser accesible desde cualquier clase de
dispositivo con acceso a internet. Así pues, la única restricción disponible
para los clientes es que cuenten con un navegador modern que provea de acceso
web y sea compatible con los últimos estándares web.

\subsubsection{Cliente de acceso Android}

Los clientes que quieran acceder mediante la aplicación Android deberán contar
con un dispositivo que soporte como mínimo la versión 2.3 del sistema operativo
Android. Además, estos dispositivos deberán tener acceso a internet en general,
y a los Google Play Services en particular.

\subsection{Arquitectura lógica}

La arquitectura lógica del sistema está formada por los elementos software
(servicios, aplicaciones, librerías, frameworks, etc.) que componen el software
base, más el software desarrollado para cumplir los requisitos de la
aplicación. En esta sección se muestra la organización de los distintos
elementos software que componen el proyecto así como la comunicación entre
ellos. 

En la figura~\ref{fig:arquitectura-logica} se puede ver un esquema de cómo se
comunican los diferentes elementos que conforma el sistema web a alto nivel. En
detalle, el flujo que sigue en cada capa es el siguiente.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{5_diseno/diagrama_arquitectura_logica}
  \caption{Arquitectura lógica del sistema web}
  \label{fig:arquitectura-logica}
\end{figure}


\paragraph{Navegador}

Cuando un usuario desea acceder a SiteUp, abre un cliente web (habitualmente un
\textbf{navegador} web) y teclea la \ac{URL}. A partir de ahí, el navegador debe
obtener el contenido de la web. Para ello (ignorando cuestiones de bajo nivel,
como el envío de peticiones ARP o resoluciones de DNS) la acción fundamental es
hacer una \textbf{petición HTTP} al servidor que se encuentra en la URL
indicada. Esto se traduce en abrir una conexión TCP al puerto 80 del servidor
remoto y enviar unas cabeceras en las que se indique, entre otras cosas, qué
datos se quiere obtener.

\paragraph{Servidor proxy inverso}

En el servidor debe existir algún \textbf{servicio} que sea capaz de escuchar y
disponer peticiones en el puerto 80 del servidor (el número el puerto puede
variar). En nuestro caso el servidor deberá tener instalado \textbf{Nginx}, un
servidor web/proxy inverso que recibirá las peticiones HTTP del exterior. En
estas peticiones, enviadas por el navegador, se detalla qué recurso se necesita
enviar. 

En el caso de recursos estáticos, como por ejemplo ficheros de imágenes o
archivos de hojas de estilo en cascada (\ac{CSS}), es buena práctica que sea el
propio servidor el que sirva estos ficheros, dado que no necesitan de ningún
procesado dinámico, por lo que no tiene sentido desperdiciar recursos pasando la
petición al código Python.

En el caso de recursos dinámicos, esto es, las peticiones web a páginas
generadas dinámicamente, Nginx actuará de proxy inverso y pasará la petición al
manejador que se haya configurado. 

\paragraph{Servidor de aplicaciones Python}

Como se ha comentado, el proxy inverso ha detectado que hay una petición
dinámica y según su configuración la ha pasado al servidor de aplicaciones
Python. En el caso de nuestro proyecto se tratará del servidor
\textbf{Gunicorn}. Gunicorn sigue un model conocido como \textit{pre-fork
  worker}, que básicamente consiste en instanciar (\textit{forkear}) varios
procesos al lanzar el servidor que se encargarán de procesar las peticiones de
forma paralela, según el proceso padre las vaya repartiendo.

En el mundo del desarrollo web en Python se ha establecido un estándar, conocido
como \ac{WSGI}, que regula la forma en la que las aplicaciones web escritas en
Python se comunican con un servidor web. Por ello, cuando un worker recibe una
petición lo primero que hace es comunicarse con la interfaz WSGI de la
aplicación que se vaya a ejecutar, pasándole la petición y un puntero a un
\textit{callback} al que informar cuando la respuesta a la petición esté
lista. 

\paragraph{Punto de entrada WSGI}

Como se ha comentado, el worker del servidor de aplicaciones se comunica con la
interfaz WSGI. Todas las aplicaciones desarrolladas en Django cuentan con un
módulo \texttt{wsgi.py} que actúa como punto de entrada WSGI y que directamente
pasa la petición al \textit{middleware} de Django que empieza el procesamiento.

\paragraph{Middleware Django y aplicación}

A partir de este punto, la petición va rebotando entre código propio del
framework Django y código de la aplicación. El flujo habitual, en su forma más
básica es el siguiente:

\begin{enumerate}
\item Los módulos de \textit{middleware} que gestionan las peticiones reciben la
  petición actual.
\item Django revisa el fichero \texttt{urls.py} de la aplicación, que contiene
  una lista de URLs asociadas a funciones. Django compara la URL de la petición
  recibida y mira si coincide con alguna de las URLs del proyecto.
\item Si no hay coincidencia, Django devuelve una respuesta negativa,
  normalmente en forma de código de estado 404.
\item Si hay coincidencia, Django llama a la función asociada a esa URL --
  conocida como la \textbf{vista}. La vista procesa la petición, devolviendo una
  respuesta.
\item Esa respuesta hace el camino de forma inversa, pasando por todos los pasos
  hasta el cliente.
\end{enumerate}

Entrando más en detalle, una aplicación de Django se organiza en una
arquitectura de módulos pequeños o \textit{aplicaciones}, cada una de las cuales
debe tener una serire de responsabilidades reducida y acotada, de forma que sea
relativamente sencillo intercambiar las aplicaciones por otras. En el caso del
proyecto SiteUp, se cuenta con tres aplicaciones:

\begin{itemize}
\item \textbf{siteup\_frontend} gestiona las vistas de la aplicación, recibe las
  peticiones, muestra las páginas y gestiona formularios.

\item \textbf{siteup\_api} recibe las órdenes de \texttt{siteup\_frontend},
  haciendo los cambios necesarios en la base de datos, dando de alta las tareas
  y procesando resultados.

\item \textbf{siteup\_checker} cuenta con el código de bajo nivel para hacer los
  chequeos de diferentes tipos. Es principalmente una aplicación tipo
  \textit{helper}.

\end{itemize}

Cada aplicación en Django cuenta con una arquitectura de tres capas conocida
como \textbf{Modelo-Vista-Plantilla}, que se asimila al clásico patrón del
\textbf{Modelo-Vista-Controlador}.

\begin{itemize}
\item El \textbf{modelo} representa la información en la base de datos, evitando
  al usuario tener que utilizar código SQL. Para ello, Django cuenta con un
  \ac{ORM} que facilita el trabajo con registros de la base de datos.
\item Las \textbf{vistas} suelen ser funciones asociadas a una URL. La filosofía
  de Django es que las vistas sirvan solo como \textit{punto de paso} de los
  datos entre los modelos y las plantillas. Es mala práctica colocar lógica de
  negocio compleja en las vistas.
\item Las \textbf{plantillas} son la representación final de los datos, lo que
  acaba viendo el usuario. Las plantillas suelen estar escritas en HTML aunque
  pueden también representarse usando JSON, XML, etc.
\end{itemize}

La organización física de ficheros de un proyecto Django se ajusta perfectamente
a la organización lógica hasta ahora descrita, siendo habitual tener un árbol de
ficheros similar al siguiente:

\begin{itemize}
\item Raíz del proyecto
\item \texttt{siteup} --  Directorio de proyecto general.
  \begin{itemize}
  \item \texttt{settings.py} -- Configuración general.
  \item \texttt{urls.py} -- Configuración de URLs.
  \item \texttt{wsgi.py} -- Punto de acceso WSGI.
  \end{itemize}
\item \texttt{siteup\_api} --  Directorio para la app (suele haber más de uno).
  \begin{itemize}
  \item \texttt{views.py} -- Definición de vistas (funciones).
  \item \texttt{models.py} -- Definición de modelos.
  \item \texttt{tests.py} -- Definición de tests.
  \end{itemize}
\end{itemize}

Opcionalmente, las aplicaciones de Django pueden contar con ficheros
individuales para otros elementos, como formularios, mánagers, migraciones,
validadores, utilidades, filtros, procesadores de contexto, etcétera.

\paragraph{Servidor de tareas asíncronas}

Habrá peticiones en SiteUp cuyo objetivo sea dar de alta chequeos. Éstos dan
lugar a nuevas tareas que serán ejecutadas asíncronamente. Celery, el servidor
de tareas que se utiliza, cuenta con una arquitectura de \textit{workers}
similar a Gunicorn, que se reparten las tareas que son dadas de alta por
SiteUp. Estas tareas se ejecutan de forma periódica. 

Tras su conclusión, Celery se comunica con Django para dejar constancia de los
resultados de esas tareas en forma de modelos de la base de datos.

\paragraph{Broker de mensajes}

Por debajo de Celery se encuentra el \textit{bróker} de mensajes, que implementa
el ya mencionado estándar \ac{AMQP}. El bróker se encarga de almacenar las
tareas y sus resultados en forma de mensajes en una cola. 

En este proceso es necesario \textit{traducir} las tareas a un formato que sea
almacenable y gestionable en una cola. En el caso de Django lo más habitual es
utilizar Pickle, el estándar de facto para la serialización de objetos Python.

\section{Diseño físico de datos}

En la figura~\ref{fig:diagrama-modelos} se muestra el diagrama de modelos que se
reflejará en la base de datos, donde se puede apreciar cada una de las tablas
que forman el proyecto, así como los campos de las tablas y las relaciones entre
ellas.

\begin{figure}[htbp]
  \centering
  \includegraphics[angle=90, width=\textwidth]{5_diseno/diagrama-modelos}
  \caption{Diseño de la base de datos}
  \label{fig:diagrama-modelos}
\end{figure}

El diseño de los datos se ha hecho mediante las herramientas de mapeo
objeto-relacional que ofrece el framework Django. A continuación se detallan los
principales modelos con los que cuenta el sistema.

\subsection{User}

Este modelo representa a un usuario registrado en el sistema. Es un modelo
predeterminado de Django y forma parte de la aplicación \texttt{django.contrib.auth}.

Sus principales campos son:

\begin{itemize}
\item \texttt{username} - Nombre de usuario.
\item \texttt{password} - Contraseña. Se almacena en forma de cifrado
  irreversible de acuerdo a las exigencias de la actual Ley de Protección de Datos.
\item \texttt{email} - Dirección de correo electrónico.
\end{itemize}

\subsection{UserExtra}

Este modelo guarda información adicional sobre los usuarios, evitando así tener
que modificar el modelo que integra Django. Forma parte de la aplicación \texttt{siteup\_api}.

Sus principales campos son:

\begin{itemize}
\item \texttt{send\_report} - Booleano, indica si el usuario recibirá reportes
  diarios sobre el estado de sus chequeos.
\item \texttt{regid} - Texto, guarda el identificador único del dispositivo
  Android obtenido a través de Google Play Services.
\end{itemize}

\subsection{CheckGroup}

Parte de la aplicación \texttt{siteup\_api}. Identifica a un grupo de
chequeos. Todos los chequeos deben pertenecer a un grupo. 

El campo principal de este modelo es \texttt{title}, que guarda una cadena con
el título del grupo.

\subsection{BaseCheck}

Parte de la aplicación \texttt{siteup\_api}. Este modelo \textbf{abstracto}
guarda campos comunes a todos los tipos de chequeos. No tiene representación
directa en la base de datos, sino que sirve para evitar duplicidad de código.

Sus principales campos son:

\begin{itemize}
\item \texttt{title} - Texto, representa el título del chequeo.
\item \texttt{description} - Texto, representa la descripción del chequeo.
\item \texttt{is\_active} - Booleano, indica si el chequeo está activo.
\item \texttt{check\_interval} - Entero, indica el intervalo entre chequeos en minutos.
\item \texttt{notify\_email} - Booleano, indica si los cambios de estado del
  chequeo se notificarán vía correo electrónico.
\item \texttt{notify\_android} - Booleano, indica si los cambios de estado del
  chequeo se notificarán vía Android utilizando notificaciones push.
\item \texttt{last\_log\_datetime} - Fecha, almacena la fecha de la última vez que se lanzó el chequeo.
\end{itemize}

\subsection{DnsCheck}

Parte de la aplicación \texttt{siteup\_api}. Este modelo deriva de
\texttt{BaseCheck} y representa un chequeo de registros DNS. Sus principales campos son:

\begin{itemize}
\item \texttt{target} - Texto, indica el dominio a chequear.
\item \texttt{record\_type} - Enum, indica el tipo de registro a chequear. Puede ser de tipo A, AAAA, CNAME, MX y TXT.
\item \texttt{resolved\_address} - Texto, indica el contenido que debe tener el registro revisado.
\end{itemize}

\subsection{HttpCheck}

Parte de la aplicación \texttt{siteup\_api}. Este modelo deriva de
\texttt{BaseCheck} y representa un chequeo a través de peticiones HTTP.

Sus principales campos son:

\begin{itemize}
\item \texttt{target} - Texto, indica la URL a comprobar.
\item \texttt{status\_code} - Entero, indica el código de estado que se debe recibir.
\item \texttt{content\_check\_string} - Cadena, representa una cadena de texto
  que, opcionalmente, debe estar presente en la respuesta obtenida desde la URL indicada.
\end{itemize}

\subsection{PortCheck}

Parte de la aplicación \texttt{siteup\_api}. Este modelo deriva de
\texttt{BaseCheck} y representa un chequeo de puertos remotos.

Sus principales campos son:

\begin{itemize}
\item \texttt{target} - Cadena, identifica el servidor remoto al que conectarse.
\item \texttt{target\_port} - Entero, indica el puerto remoto al que conectarse.
\item \texttt{response\_check\_string} - Cadena, representa una cadena de texto
  que, opcionalmente, debe estar presente en la respuesta obtenida desde el servidor.
\end{itemize}

\subsection{PingCheck}

Parte de la aplicación \texttt{siteup\_api}. Este modelo deriva de
\texttt{BaseCheck} y representa un chequeo mediante el envío de paquetes \ac{ICMP}.

Sus principales campos son:

\begin{itemize}
\item \texttt{target} - Cadena, identifica al servidor remoto que hay que chequear.
\item \texttt{should\_check\_timeout} - Booleano, indica si hay que comprobar el tiempo de respuesta de los paquetes ping.
\item \texttt{timeout\_value} - Entero, si el anterior campo evalúa a
  \textit{Verdadero}, este campo guarda el tiempo de respuesta máximo permitido.
\end{itemize}

\subsection{CheckLog}

Parte de la aplicación \texttt{siteup\_api}. Es un registro (\textit{log}) que
representa el resultado de ejecutar un chequeo.

Sus principales campos son:

\begin{itemize}
\item \texttt{date} - Fecha, representa el momento en el que se obtuvo el resultado.
\item \texttt{status} - Entero, representa el estado del chequeo que se ha
  obtenido. Los posibles valores son:
  \begin{itemize}
  \item 0: el chequeo ha terminado correctamente y el estado es correcto (\textit{Up}).
  \item 1: el chequeo ha terminado correctamente y el estado es negativo (\textit{Down}).
  \item 2: el chequeo no ha podido concluirse. Equivalente en estadísticas al estado negativo. (\textit{Error}).
  \end{itemize}
\item \texttt{response\_time} - Entero, solo válido para los chequeos de tipo
  Ping. Guarda el tiempo de respuesta obtenido.
\item \texttt{collapse\_level} - Entero. Indica el nivel de \textit{colapsado}
  del registro. Dado que el número de registros es muy alto (en una hora pueden
  llegar a generarse más de 3600 registros por chequeo), es necesario resumir
  los registros más antiguos. Este campo indica si el \textit{CheckLog} ya ha
  sido resumido o no.
\end{itemize}

\subsection{CheckStatus}

Parte de la aplicación \texttt{siteup\_api}. Representa un cambio de estado de
un chequeo. Cuando un chequeo es ejecutado, se genera una instancia de
\textit{CheckLog} y se comprueba el estado de éste con el estado de la última
comprobación. Si se verifica que el estado ha cambiado con respecto a los
últimos estados, se genera una instancia de \textit{CheckStatus} y se lanzan las
notificaciones pertinentes.

Los campos principales de este modelo son:

\begin{itemize}
\item \texttt{status} - Entero, indica el estado. El código numérico responde al
  mismo formato que se sigue en el modelo \textit{CheckLog}.
\item \texttt{status\_extra} - Cadena, guarda información adicional sobre el estado.
\item \texttt{date\_start} - Fecha, indica el momento en el que el chequeo
  cambia a este estado.
\item \texttt{date\_end} - Fecha, indica el momento en el que el chequeo deja de
  estar en este estado. Si es el estado actual de un chequeo, se mantiene en blanco.
\item \texttt{notified} - Booleano, indica si este cambio de estado ha sido ya notificado.

\end{itemize}

\subsection{Session}

Parte de la aplicación \texttt{django.contrib.sessions}. Representa una sesión
de usuario en la aplicación web. Sus campos principales son:

\begin{itemize}
\item \texttt{session\_key} - Cadena, guarda el identificador de la sesión.
\item \texttt{session\_data} - Texto, guarda los datos asociados a la sesión.
\item \texttt{expire\_date} - Fecha, indica hasta qué fecha son válidos los
  datos de la sesión.
\end{itemize}

\subsection{MigrationHistory}

Parte de la aplicación \texttt{south}. Representa una migración de la base de
datos. Los campos principales son:

\begin{itemize}
\item \texttt{app\_name} - Cadena, nombre de la app sobre la que se ahce la migración.
\item \texttt{migration} - Cadena, identificador de la migración.
\item \texttt{applied} - Fecha, indica cuándo se aplicó la migración.
\end{itemize}

\subsection{ContentType}

Parte de la aplicación \texttt{django.contrib.contenttypes}. Es el bloque
principal del \textit{Content Types Framework}, un framework integrado en Django
que permite trabajar de forma genérica con los modelos, ofreciendo
funcionalidades como la posibilidad de crear claves foráneas genéricas (es
decir, que puedan apuntar a cualquier modelo. 

Una instancia de \textit{ContentType} representa un modelo particular de una
aplicación en concreto. Los campos que contiene son:

\begin{itemize}
\item \texttt{name} - Cadena, nombre del modelo en formato legible.
\item \texttt{model} - Cadena, nombre original del modelo.
\item \texttt{app\_label} - Cadena, nombre de la aplicación a la que pertence el
  módulo.
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../memoria"
%%% End: 
